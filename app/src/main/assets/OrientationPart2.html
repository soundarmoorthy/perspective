<HTML>
	<HEAD>
		<LINK REL=StyleSheet HREF="style.css" TYPE="text/css" MEDIA=screen>
<TITLE>Rotations and Orientation: Part 2</TITLE>
</HEAD>
<BODY>
	<H1>Rotations and Orientation: Part 2</H1>
	<H2>Axis &amp; Angle</H2>
At the end of <a href="OrientationPart1.html">Rotations and Orientation: Part 1</a>, we alluded to the fact that there might be more efficient ways of describing rotations.  Let's start with the rotation of a simple rigid body (in this case a cylinder) as shown in Figure 1.  Here, the cylinder is rotated such that a point on it's surface originally at "A" is rotated to point "B" in space.</p>
<center>
	<p><a href="images/rotation0.png"><img  class="mod" src="images/rotation0.png" ></a></p> 
<p>Figure 1: Rotation of a rigid body such that a reference point moves from "A" to "B"</p>
</center> 
    <p>For this simple case, We've kept the axis of rotation along the vertical axis of the cylinder as shown in Figure 2. But that is not a requirement for the underlying mathematics to work. So long as we have a rigid body, we can always describe the rotation in the manner that follows.</p> 
<center>
	<p><a href="images/rotation1.png"><img  class="mod" src="images/rotation1.png" ></a></p> 
    <p>Figure 2: Overlay of Cartesian Coordinates onto System of Figure 1</p> 
</center>
    <p>Figure 3 deals with the same rotation, but focuses on the fact that we have a rotation plane that is perpendicular with the axis of rotation. The movement of the cylinder is a rotation equal of angle &alpha;, about the axis of rotation, where the point of interest is constrained to lie within the rotation plane.</p> 
<center>
	<p><a href="images/rotation2.png"><img  class="mod" src="images/rotation2.png" ></a></p> 
    <p>Figure 3: Looking at Just the Rotation Plane and Axis of Rotation</p> 
</center>

<p>The rotation is fully described by the three components of the normalized rotation axis and the rotation angle &alpha;, which may be in radians or degrees, depending upon the system in use. 
<H2>Applicability to Graphics Engines</H2>
The OpenGL ES graphics programming library is targeted at portable devices. In OpenGL ES, you build up 3 dimensional objects as a collection of triangles, which can then be offset and/or rotated to change perspective. As an example, our cylinder might be crudely drawn as shown in Figure 4.</p> 
<center>
	<p><a href="images/cylinder.gif"><img  class="mod" src="images/cylinder.gif"></a></p> 
    <p>Figure 4: OpenGL ES Drawing of a Cylinder</p> 
</center>
    <p>In this case, We've modeled the top and bottom of the cylinder with 6 triangles each, and the other side is modeled using a total of 16 triangles arranged in a strip. OpenGL ES is optimized to draw such structures efficiently, and it is possible to then "render" textures onto the drawn surfaces. What's really neat is that once drawn, we get a reasonable approximation of the cylinder of Figure 1 simply by doing a -30 degrees rotation about the Z axis (presumed to be out of the page) using a single OpenGL ES instruction:</p> 
    <p><center>gl.glRotatef(-30.0f, 0.0f, 0.0f, 1.0f);</center></p> 
    <H2><a id="quaternions">Quaternions</a></H2>
    <H3>Introduction</H3>
    <P>At this point, you're probably thinking: "Yeah, that makes sense, but how does it work at the math level?" This is the where we need to introduce the concept of a <strong>quaternion</strong>. 
Conceptually, a quaternion encodes the same axis and angle as above. But for mathematical reasons it deals with 1/2 of the rotation angle as shown below.
   </p> 
<center>
	<p><a href="images/rotation3.png"><img  class="mod" src="images/rotation3.png"></a></p> 
    <p>Figure 5: System of Figure 4 in Terms of Quaternion Components</p> 
</center>
    <p>Before overwhelming you with the underlying math, you should know that unless you are planning to implement your own quaternion utility library, you only need to know a few key points:</p> 
    <ol> 
   <li>It takes four numbers to fully describe a quaternion (commonly q0 through q3).</li>
    <li>Not all quaternions are rotation quaternions.  Rotation quaternions have unit length. The discussion below will be restricted to rotation quaternions.</li> 
    <li>These same rotations can be described using Euler angles, rotation matrices, etc. as discussed in the previous posting. It is possible (and common) to translate between formats and use multiple formats. 
    Rotation matrices have the advantage of always being unique.  Euler angles are subject to gimbal lock, and should not be used for internal calculations (only input/output of results).</li>
    <li>You can rotate a vector <strong>V</strong> using a quaternion q using the equation: <strong>W</strong> = q<strong>V</strong>q* (quaternion products and complex conjugates are defined later)</li> 
    <li>A sequence of rotations represented by quaternions q1 followed by q2 can be collapsed into a single rotation simply by computing the quaternion product q=q2q1 and then appling the rotation operator as above.</li> </ol> 
<H3>Mathematical Details</H3>
    <p>We will be presenting the mathematical definition first, and without proof. If you really, REALLY want to know the underlying theory, let me suggest that you pick up a copy of Jack Kuiper's excellent text: Quaternions and Rotation Sequences. This appears to be (by far) the most extensive treatment on the topic, even while remaining very readable.</p> 
    <p>Notice that rotation quaternions deal with <strong>&alpha;/2</strong>, not &alpha;. We can define a rotation quaternion "q" in one of several equivalent fashions</p>
 <table  class="eqn" >
  <tr>
   <td  class="eqn">q = (q0, q1, q2, q3)
   </td>
   <td  class="eqnNum">(Eqn.1)
   </td>
  </tr>
  <tr>
   <td  class="eqn">q = q0 + q, where q = iq1 + jq2 + kq3
   </td>
   <td  class="eqnNum">(Eqn. 2)
   </td>
  </tr>
  <tr>
   <td  class="eqn">q = cos(&alpha;/2) + <strong>u</strong> sin(&alpha;/2), where <strong>u</strong> is the vector axis of rotation
   </td>
   <td  class="eqnNum">(Eqn. 3)
   </td>
  </tr>
 </table> 
    <p>In this discussion, use the quaternion form where q0 = cos(&alpha;/2). Some texts will reorder the quaternion components so that the vector portion <strong>q</strong> is contained in q0-2 and q3 = cos(&alpha;/2). Be sure you understand which form your text/software library supports.</p> 
    <p>Quaternions are a form of hyper-complex number where instead of a single real and single imaginary component, we have one real and THREE imaginary components (i, j &amp; k). Rules for these imaginary components are:</p>
 <table   class="eqn">
  <tr>
   <td  class="eqn">i<sup>2</sup> = j<sup>2</sup> = k<sup>2</sup> = ijk = -1
   </td>
   <td  class="eqnNum">(Eqn. 4)
   </td>
  </tr>
  <tr>
   <td  class="eqn">ij = k = -ji
   </td>
   <td  class="eqnNum">(Eqn. 5)
   </td>
  </tr>
  <tr>
   <td  class="eqn">jk = i = -kj
   </td>
   <td  class="eqnNum">(Eqn. 6)
   </td>
  </tr>
  <tr>
   <td  class="eqn">ki = j = -ik
   </td>
   <td  class="eqnNum">(Eqn. 7)
   </td>
  </tr>
 </table> 
    <p>Two quaternions, p and q, are equal to one another only if the individual components are equal. You add two quaternions by adding the individual components. If</p>
 <table   class="eqn">
  <tr>
   <td  class="eqn">p = p0 + ip1 + jp2 + kp3; and
   </td>
   <td  class="eqnNum">(Eqn. 8)
   </td>
  </tr>
  <tr>
   <td  class="eqn">q = q0 + iq1 + jq2 + kq3
   </td>
   <td  class="eqnNum">(Eqn. 9)
   </td>
  </tr>
 </table> 
    <p>Then</p>
 <table   class="eqn">
  <tr>
   <td  class="eqn">p + q = (p0 + q0) + i(p1+q1) + j(p2+q2) + k(p3+q3)
   </td>
   <td  class="eqnNum">(Eqn. 10)
   </td>
  </tr>
 </table> 
    <p>The addition operation commutes. That is p+q = q+p. Multiplication of a quaternion by a scalar real number is trivial, just multiply each of the four components by the scalar. Multiplication of two quaternions is NOT so trivial:</p>
 <table   class="eqn">
  <tr>
   <td  class="eqn"> 
    <p>pq = p0q0 - <strong>p</strong>.<strong>q</strong> + p0<strong>q</strong> + q0<strong>p</strong> + <strong>p</strong> x <strong>q</strong></p>
   </td>
   <td  class="eqnNum">(Eqn. 11)
   </td>
  </tr>
 </table> 
    <p>Multiplying one quaternion by another quaternion results in a third quaternion. Notice that the 1st two components (p0q0 - <strong>p</strong>.<strong>q</strong>) makes up the scalar portion of the result, and the last three (p0<strong>q</strong> + q0<strong>p</strong> + <strong>p</strong> x <strong>q</strong>) comprise the vector portion. The quaternion product operation is not commutative pq&ne;qp. Order matters. Multiplication of two quaternions includes scalar, cross product and dot product terms. Unless you are writing your own quaternion library, you are likely never to use the expression above. Instead, you will use a function that does the quaternion multiplication for you.</p> 
    <p>The complex conjugate of</p>
 <table   class="eqn">
  <tr>
   <td  class="eqn">q = q0 + iq1 + jq2 + kq3 is q* = q0 - iq1 - jq2 - kq3
   </td>
   <td  class="eqnNum">(Eqn. 12)
   </td>
  </tr>
 </table> 
    <p>Related to this, we have</p>
 <table  class="eqn">
  <tr>
   <td  class="eqn">(pq)* = q*p*
   </td>
   <td  class="eqnNum">(Eqn. 13)
   </td>
  </tr>
  <tr>
   <td  class="eqn">q+q* = 2q0
   </td>
   <td  class="eqnNum">(Eqn. 14)
   </td>
  </tr>
  <tr>
   <td  class="eqn">q<sup>-1</sup> = q* for any unit quaternion
   </td>
   <td  class="eqnNum">(Eqn. 15)
   </td>
  </tr>
 </table> 
    <p>Eqn. 15 is interesting. If you think of a quaternion as a rotation operator, it says you can reverse the sense of rotation by inverting the axis of rotation. Given our usual standard of using the Right Hand Rule to describe the polarity of rotations, this makes perfect sense. Reversing the direction of the axis is equivalent to reversing the direction of rotation.</p> 
    <p>Another interesting take on the above is that rotation quaternions are not unique:</p>
 <table  class="eqn">
  <tr>
   <td  class="eqn">q = -q
   </td>
   <td  class="eqnNum">(Eqn. 16)
   </td>
  </tr>
 </table> 
<p>Any rotation quaternion can be multiplied by -1 and still result in the same rotation! That's because we reversed both the angle AND the axis of rotation (which then cancel each other). 
It is conventional therefore to remove the ambiguity by negating a rotation quaternion if its scalar component is negative.
</p> 
<H2>Why do we care?</H2>
    <p>At this point, you are surely wondering why in the world you might, or might not, choose to use quaternions instead of rotation matrices. Here's a brief summary of the pros and cons:</p>
 <table>
	 <thead>
  <tr>
   <th><strong>Topic</strong>
   </th>
   <th><strong>Quaternion</strong>
   </th>
   <th><strong>Rotation Matrix</strong>
   </th>
  </tr>
  </thead>
  <tr>
   <td>Storage
   </td>
   <td>Requires <strong>16 bytes</strong> of storage in single precision floating point (4 elements at 4 bytes each)
   </td>
   <td>Requires <strong>36 bytes</strong> of storage (9 elements at 4 bytes each)
   </td>
  </tr>
  <tr>
   <td>Computation (for 2 sequential rotations)
   </td>
   <td>4 elements each requiring 4 multiplies and 3 additions =<strong> 28 operations</strong>
   </td>
   <td>9 elements, each requiring 3 multiplies and 2 additions = <strong>45 operations</strong>
   </td>
  </tr>
  <tr>
   <td>Vector rotation
   </td>
   <td>Rotating a vector by pre- and post-multiplication of quaternion requires <strong>52 operations</strong>
   </td>
   <td>Rotating a vector via rotation matrix requires <strong>15 operations</strong> (3 elements each requiring 3 multiplies and 2 additions)
   </td>
  </tr>
  <tr>
   <td>Discontinuities
   </td>
   <td>Generally, we force the scalar part of the quaternion to be positive, which can cause a discontinuity in the rotation axis (it flips).
   </td>
   <td>None
   </td>
  </tr>
  <tr>
   <td>Ease of Understanding
   </td>
   <td>Generally takes a lot of study to understand the details
   </td>
   <td>Easily understood by most engineers
   </td>
  </tr>
  <tr>
   <td>Conversion
   </td>
   <td>From rotation matrix =
 <table>
  <tr>
   <td>m11
   </td>
   <td>m12
   </td>
   <td>m13
   </td>
  </tr>
  <tr>
   <td>m21
   </td>
   <td>m22
   </td>
   <td>m23
   </td>
  </tr>
  <tr>
   <td>m31
   </td>
   <td>m32
   </td>
   <td>m33
   </td>
  </tr>
 </table> 
    we have:
    <br>q0 = 0.5 sqrt(m11 + m22 + m33 + 1)
    <br>q1 = (m32 - m23) / (4q0)
    <br>q2 = (m13 - m31) / (4q0)
    <br>q3 = (m21 - m12) / (4q0) (Eqn. 17)
   </td>
   <td>RM =
 <table>
  <tr>
   <td>2q0<sup>2</sup> - 1 + 2q1<sup>2</sup>
   </td>
   <td>2q1q2 - 2q0q3
   </td>
   <td>2q1q3 +2q0q2
   </td>
  </tr>
  <tr>
   <td>2q1q2 + 2q0q3
   </td>
   <td>2q0<sup>2</sup> - 1 + 2q2<sup>2</sup>
   </td>
   <td>2q2q3 - 2q0q1
   </td>
  </tr>
  <tr>
   <td>2q1q3 - 2q0q2
   </td>
   <td>2q2q3 + 2q0q1
   </td>
   <td>2q0<sup>2</sup> -1 + 2q3<sup>2</sup>
   </td>
  </tr>
 </table> 
    <p>(Eqn. 18)</p>
   </td>
  </tr>
 </table> 
 <P>Equations 17 and 18 are consistent with regards to direction of rotation.  If instead of rotating a vector in a fixed frame of reference, you rotate the frame of reference itself, then need to use the transpose of Eqn. 18 and invert q1, q2 and q3 in Eqn. 17.
 <p>Returning to the quaternion rotation operator <strong>W</strong> = q<strong>V</strong>q*, note that <strong>V</strong> needs to be expressed as a quaternion of the form [0, vx, vy, vz], and the multiplications are quaternion multiplies as defined in Eqn. 11. q* is the complex conjugate defined in Eqn. 12.</p> 
    <p>If you do a lot of graphics or sensor fusion work, you will probably find yourself constantly switching between the various representations we've considered. You'll find it useful to remember a couple of identities from your high school geometry course:</p>
 <table>
  <tr>
   <td>The Dot Product
   </td>
   <td> 
    <p><strong>u</strong> . <strong>v</strong> = | <strong>u</strong> | |<strong> v</strong> | cos &alpha; (Eqn. 19)</p> 
    <p>If both <strong>u</strong> and <strong>v</strong> are unit vectors, then:</p> 
    <p><strong>u</strong> . <strong>v</strong> = cos &alpha; (Eqn. 20)</p>
   </td>
   <td><a href="images/dot_product.png"><img  class="eqnFull" src="images/dot_product.png">(click to expand)</a>
   </td>
  </tr>
  <tr>
   <td>The Cross Product
   </td>
   <td> 
    <p><strong>u</strong> x<strong> v</strong> = | <strong>u</strong> | |<strong> v</strong> | sin &alpha;<strong> n</strong> (Eqn. 21)</p> 
    <p>where n is a unit vector perpendicular to the plane containing <strong>u</strong> and<strong> v</strong> (the polarity of <strong>n</strong> follows the right hand rule).</p> 
    <p>If both <strong>u</strong> and <strong>v</strong> are unit vectors, then:</p> 
    <p><strong>n</strong> = <strong>u</strong> x <strong>v</strong> / (sin &alpha;) (Eqn. 22)</p>
   </td>
   <td><a href="images/cross_product.png"><img class="eqnFull" src="images/cross_product.png">(click to expand)</a>
   </td>
  </tr>
 </table> 
    <p>If you've been paying attention, you will see that &alpha; is the rotation of <strong>u</strong> into <strong>v</strong> about the axis of rotation defined by <strong>u</strong> x <strong>v. </strong>See! It's simple! Axis and angle!</p> 
    <p><h2>References:</h2></p> 
    <ol> 
    <li>Quaternions and Rotation Sequences, Jack B. Kuipers, Princeton University Press, 1999</li> 
    <li><a href="http://demonstrations.wolfram.com/EulerAngles/">Euler Angles</a> from the <a href="http://demonstrations.wolfram.com/">Wolfram Demonstrations Project</a> by Frederick W. Strauch</li> 
    <li>Diversified Redundancy in the Measurement of Euler Angles Using Accelerometers and Magnetometers, Chirag Jagadish and Bor-Chin Chang, Proceedings of the 46<sup>th</sup> IEEE Conference on Decision and Control, Dec. 2007</li> 
    <li><a href="http://en.wikipedia.org/wiki/Euler_angles">Euler Angles at Wikipedia</a></li> 
    <li><a href="/community/the-embedded-beat/blog/2012/10/29/orientation-representations-part-1">Orientation Representations: Part 1</a>, Michael Stanley at the Embedded Beat, October 2012</li> </ol>
<p>Continue to <a href="algorithms.html"><strong>Algorithms</strong></a>.
<p>
</body></html>

